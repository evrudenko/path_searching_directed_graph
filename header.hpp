#ifndef _LAB2_HEADER_
#define _LAB2_HEADER_

#include <algorithm>
#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <vector>
#include <regex>

using namespace std;

/*
 * ~~~~ Описание структуры:
 * Вспомогательная структура данных, представляющая направленное ребро графа (дугу),
 * в направлении от вершины v к вершине w, стоимостью c.
*/
struct Edge {
	int v, w, c;
	Edge(int v = -1, int w = -1, unsigned c = 0) : v(v), w(w), c(c) { }
};

/*
 * ~~~~ Краткое описание назначения класса:
 * Вспомогательный шаблонный класс для ввода и вывода графов.
*/
template<typename Graph>
class IO {
private:
	/*
	 * Вспомогательныя функция замены символов, переданных в векторе extra_chars, в строке
	 * str на символ replacement. 
	*/
	inline static void replace_extra_chars(string &str,
		const vector<char> &extra_chars, const char replacement = ' ');
	/* 
	 * ~~~~ Описание функции:
	 * Вспомогательная функция форматирования строки str. Выполняет удаление лишних пробелов
	 * и всех символов, переданных в векторе extra_chars, из форматируемой строки. Использует
	 * функцию replace_extra_chars().
	 * ~~~~ Описание параметров:
	 * str - форматируемая строка; extra_chars - вектор символов, подлежащих удалению из строки.
	*/
	static void format_string(string &str, const vector<char> &extra_chars = {});
public:
	/* Функция вывода графа G в стандартный поток вывода. */
	static void show_graph(const Graph &G);
	
	/*
	 * ~~~~ Описание функции:
	 * Функция чтения графа из файла filename.
	 * ~~~~ Примечания об использовании:
	 * В случае ошибки при попытке открытия файла функция возвращает false, а если файл
	 * был открыт успешно true.
	 * Функция фактически идентифицирует ребра графа по соответствующим данным в файле
	 * filename при помощи статического метода класса Graph, Graph::scan_edges() и
	 * добавляет их в уже существующий граф G.
	 * ~~~~ Описание параметров:
	 * G - граф для записи данных; filename - имя файла с данными о графе; extra_chars -
	 * вектор символов, подлежащих удалению из текста файла (например, угловые скобки [],
	 * если данные для графа создаются автоматически без соответствующего форматирования).
	*/
	static bool read_graph(Graph &G, const string &filename, const vector<char> &extra_chars = {});
};

/*
 * ~~~~ Краткое описание класса:
 * Класс представляет граф при помощи списков смежности. Удобен для хранения
 * разрезженных графов с малым количеством ребер.
*/
class SparseGraph {
private:
	/* Объявление внутреннего итератора класса другом. Объявлен в этом же классе ниже. */
	friend class adjIterator;

	/*
	 * Вспомогательная структура данных, представляющая звено (узел) списка и используемая
	 * в списках смежности.
	*/
	struct node {
		int v, c;
		node *next;
		node(int x, int p, node *n = nullptr) : v(x), c(p), next(n) { }
	};

	/* Синоним указателя на node (узел списка) определен для удобства. */
	typedef node* link;

	vector<link> adjLists;
	int v_cnt, e_cnt;
	bool _directed;

	/* Вспомогательная функция удаления узла l->next из списка, в котором он находится. */
	inline void delete_next(link l);

	/*
	 * ~~~~ Описание функции:
	 * Вспомогательная функция проверки существования пути из вершины
	 * from_v в вершину to_v в графе.
	 * ~~~~ Примечания:
	 * Если ребро существует, функция возвращает его стоимость, иначе возвращает 0.
	*/
	inline int path_exists(int from_v, int to_v) const;
public:
	/*
	 * Конструктор.
	 * ~~~~ Описание параметров:
	 * V - количество вершин; _directed - параметр, определяющий направленность/
	 * ненаправленность графа, в зависимости от этого параметра далее ребра будут
	 * добавляться/удаляться парами (например, при добавлении ребра Edge(1, 2)
	 * будет также добавлено ребро Edge(2, 1), аналогично с удалением).
	 */
	SparseGraph(int V, bool _directed = true);

	/* Деструктор. Освобождает память, выделенную под списки смежности. */
	~SparseGraph();

	/* Функция возвращает количество вершин в графе. */
	inline int V() const;

	/* Функция возвращает количество ребер в графе. */
	inline int E() const;

	/* Функция проверки графа на ориентированность. */
	inline bool directed() const;

	/*
	 * ~~~~ Описание функции:
	 * Функция проверки существования ребра e. 
	 * ~~~~ Примечания:
	 * Если ребро существует, функция возвращает его стоимость, иначе возвращает 0.
	 */
	inline int edge(Edge e) const;

	/*
	 * ~~~~ Описание функции:
	 * Функция проверки существования ребра, ведущего из вершины v в вершину w.
	 * ~~~~ Примечания:
	 * Если ребро существует, функция возвращает его стоимость, иначе возвращает 0.
	*/
	inline int edge(int v, int w) const;

	/*
	 * Функция добавления ребра e в граф. В случае, если граф ненаправленнный, добавляется
	 * также "противоположно направленное" ребро.
	*/
	inline void insert(Edge e);

	/*
	 * Функция добавления в граф ребра, ведущего из вершины v в вершину w.
	 * В случае, если граф неориентированный, добавляется также ребро из w в v,
	 * стоимостью c.
	*/
	void insert(int v, int w, int c);

	/*
	 * Функция удаления ребра e из графа. Если граф ненаправленнный, удаляется
	 * также "противоположно направленное" ребро.
	*/
	inline void remove(Edge e);

	/*
	 * Функция удаления из графа ребра, ведущего из вершины v в вершину w.
	 * В случае, если граф неориентированный, удаляется также ребро из w в v.
	*/
	void remove(int v, int w);

	/*
	 * ~~~~ Описание метода:
	 * Статический метод, идентифицирующий ребра, представленные в строке data,
	 * создает их и сохраняет в векторе edges.
	 * ~~~~ Примечания:
	 * Ожидаемые данные - пары чисел, перечисленные через запятую. Числа в паре
	 * разделены символом '-'. Пара "n-m" интерпретируется как ребро из вершины n
	 * в вершину m.
	 * ~~~~ Пример:
	 * Для data = "1-2,1-3,3-2" будет идентифицирован следующий набор ребер:
	 * Edge(1, 2), Edge(1, 3), Edge(3, 2).
	*/
	static void scan_edges(vector<Edge> &res, string data);

	/*
	 * Класс, представляющий итератор списков смежности класса SparseGraph.
	 * Создается с указанием номера вершины, смежные с которой необходимо возвращать.
	*/
	class adjIterator {
	private:
		link curr;
		int V;
		const SparseGraph &G;
	public:
		/*
		 * Конструктор. Принимает граф G и номер вешины v, смежные с которой
		 * необходимо рассмотреть. При создании первая вершина в рассматриваемом
		 * списке определяется как текущая, далее текущее состояние использует
		 * метод next().
		*/
		adjIterator(const SparseGraph &G, int v);

		/*
		 * ~~~~ Описание метода:
		 * Метод возвращает номер первой смежной вершины в списке.
		 * ~~~~ Примечания:
		 * Если список смежности пуст, возвращаемое значение равно -1.
		*/
		int begin();

		/*
		 * ~~~~ Описание метода:
		 * Метод возвращает номер следующей смежной вершины в списке после
		 * текущей.
		 * ~~~~ Примечания:
		 * Если следующей вершины не существует или итератор дошел до конца
		 * списка, возвращаемое значение равно -1.
		*/
		int next();

		/*
		 * Метод проверки текущего состояния итератора. Если все смежные вершины
		 * пройдены, будет возвращено true, иначе false.
		*/
		bool end();
	};
};

/*
 * ~~~~ Краткое описание класса:
 * Класс представляет граф при помощи матрицы смежности. Удобен для хранения
 * плотных графов с большим количеством ребер.
*/
class DenseGraph {
private:
	/* Объявление внутреннего итератора класса другом. Объявлен в этом же классе ниже. */
	friend class adjIterator;

	int v_cnt, e_cnt;
	bool _directed;
	vector<vector<int>> adjMatrix;
public:
	/*
	 * Конструктор.
	 * ~~~~ Описание параметров:
	 * V - количество вершин; _directed - параметр, определяющий направленность/
	 * ненаправленность графа, в зависимости от этого параметра далее ребра будут
	 * добавляться/удаляться парами (например, при добавлении ребра Edge(1, 2, 5)
	 * будет также добавлено ребро Edge(2, 1, 5), аналогично с удалением).
	 */
	DenseGraph(int V, bool _directed = true);

	/* Функция возвращает количество вершин в графе. */
	inline int V() const;

	/* Функция возвращает количество ребер в графе. */
	inline int E() const;

	/* Функция проверки графа на ориентированность. */
	inline bool directed() const;

	/*
	 * ~~~~ Описание функции:
	 * Функция проверки существования ребра e. 
	 * ~~~~ Примечания:
	 * Если ребро существует, функция возвращает его стоимость, иначе возвращает 0.
	 */
	inline int edge(Edge e) const;

	/*
	 * ~~~~ Описание функции:
	 * Функция проверки существования ребра, ведущего из вершины v в вершину w.
	 * ~~~~ Примечания:
	 * Если ребро существует, функция возвращает его стоимость, иначе возвращает 0.
	*/
	inline int edge(int v, int w) const;
	
	/*
	 * Функция добавления ребра e в граф. В случае, если граф ненаправленнный, добавляется
	 * также "противоположно направленное" ребро.
	*/
	inline void insert(Edge e);

	/*
	 * Функция добавления в граф ребра, ведущего из вершины v в вершину w, стоимостью c.
	 * В случае, если граф неориентированный, добавляется также ребро из w в v, стоимостью c.
	*/
	void insert(int v, int w, int c);

	/*
	 * Функция удаления ребра e из графа. Если граф ненаправленнный, удаляется
	 * также "противоположно направленное" ребро.
	*/
	inline void remove(Edge e);

	/*
	 * Функция удаления из графа ребра, ведущего из вершины v в вершину w.
	 * В случае, если граф неориентированный, удаляется также ребро из w в v.
	*/
	void remove(int v, int w);

	/*
	 * ~~~~ Описание метода:
	 * Статический метод, идентифицирующий ребра, представленные в строке data,
	 * создает их и сохраняет в векторе edges.
	 * ~~~~ Примечания:
	 * Ожидаемые данные - матрица смежности. Для каждого элемента матрицы номер
	 * строки идентифицируется как номер начальной вершины, номер столбца как конечной,
	 * а значение на пересечении как стоимость дуги из начальной вершины в конечную.
	*/
	static void scan_edges(vector<Edge> &edges, string data);

	/*
	 * ~~~~ Краткое описание класса:
	 * Класс, представляющий итератор смежных вершин для заданной вершины (см.
	 * конструктор) во вмещающем классе DenseGraph.
	 * ~~~~ Примечания:
	 * Создается с указанием номера вершины, смежные с которой необходимо возвращать.
	*/
	class adjIterator {
	private:
		int curr, first, V;
		const DenseGraph &G;
	public:
		/*
		 * Конструктор. Принимает граф G и номер вешины v, смежные с которой
		 * необходимо рассмотреть. При создании первая вершина в рассматриваемом
		 * списке определяется как текущая, далее текущее состояние использует
		 * метод next().
		*/
		adjIterator(const DenseGraph &G, int v);

		/*
		 * ~~~~ Описание метода:
		 * Метод возвращает номер первой вершины, смежной с переданной вершной v.
		 * ~~~~ Примечания:
		 * Если смежных с v вершин нет, возвращаемое значение равно -1.
		*/
		int begin();

		/*
		 * ~~~~ Описание метода:
		 * Метод возвращает номер следующей смежной вершины после текущей.
		 * ~~~~ Примечания:
		 * Если следующей смежной вершины не существует или итератор дошел до
		 * конца списка, возвращаемое значение равно -1.
		*/
		int next();

		/*
		 * Метод проверки текущего состояния итератора. Если все смежные вершины
		 * пройдены, будет возвращено true, иначе false.
		*/
		bool end();
	};
};

/*
 * ~~~~ Краткое описание класса:
 * Модульный класс, использующийся для поиска картчайших путей в графе Graph.
*/
template<typename Graph>
class ShortestPathSearcher {
private:
	int v_cnt;
	vector<vector<int>> sp_tracer, sp_matrix;

	/*
	 * Вспомогательная функция, возвращающая путь из промежуточных вершин полного
	 * пути от вершины v до вершины w в строке вида -k1-k2...-kn, где k1, ..., kn -
	 * вершины графа G в кратчайшем пути v-k1-k2-...-kn-w. Используется функцией
	 * get_path().
	*/
	string trace(int v, int w) const;
public:
	/* Конструктор. */
	ShortestPathSearcher(const Graph &G);

	/*
	 * Функция возвращает строку с полным кратчайшим путем от вершины v до вершины
	 * w и его стоимостью в формате: "v-k1-k2-...-kn-w, P", где k1, ..., kn -
	 * промежуточные вершины графа G на пути от вершины v до вершины w по кратчайшему
	 * пути, а P - стоимость полного кратчайшего пути.
	*/
	string get_path(int v, int w) const;
};

/*
 * ~~~~ Краткое описание класса:
 * Модульный класс поиска путей в графе Graph.
*/
template<typename Graph>
class BreadthFirstSearcher {
private:
	const Graph &G;

	/*
	 * ~~~~ Красткое описание метода:
	 * Основной метод класса, реализующий логику поиска путей.
	 * ~~~~ Примечания:
	 * Метод использует рекурсию.
	 * ~~~~ Описание параметров:
	 * #1 v - стартовая вершина;
	 * #2 w - конечная вершина искомых путей;
	 * #3 prior_path - путь до вершины v, полученный в предыдущих вызовах (при первом вызове
	 * равен "");
	 * #4 marked - вектор пройденных на предыдущих шагах вершин (при первом вызове пуст,
	 * см. реализацию метода get_paths());
	 * #5 curr_costs - числовое значение, представляющее стоимость пути prior_path (при первом
	 * вызове равен 0).
	*/
	vector<string> bfs(int v, int w, string prior_path,
		vector<int> marked, int curr_costs) const;
public:
	/* Конструктор. */
	BreadthFirstSearcher(const Graph &G);

	/*
	 * ~~~~ Краткое описание функции:
	 * Функция поиска путей из вершины v в вершину w в графе G.
	 * ~~~~ Примечания:
	 * Каждый элемент возвращаемого вектора содержит уникальный путь, записанный в строку
	 * вида "-v-k1-k2-...-kn-w, costs", где k1, ..., kn - номера промежуточных вершин
	 * на пути, а costs - числовое значение, равное стоимости соответствующего пути.
	 * Использует внутренний метод bfs().
	*/
	vector<string> get_paths(int v, int w) const;
};

#endif // _LAB2_HEADER_